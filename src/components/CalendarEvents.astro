---
import CalendarEvent from "./CalendarEvent.astro";
import { useTranslations } from "../i18n/utils";
import type { Locale } from "../config/i18n";

const API_KEY = import.meta.env.CALENDAR_API_KEY;
const CALENDAR_ID = import.meta.env.CALENDAR_ID;
export interface CalendarEventsProps {
  maxEvents?: number;
  title?: string;
  lang?: Locale;
}

const {
  title = "",
  lang = "ro",
} = Astro.props as CalendarEventsProps;
const t = useTranslations(lang);
interface GoogleCalendarEvent {
  summary: string;
  description?: string;
  htmlLink?: string;
  start: {
    date?: string;
    dateTime?: string;
    timeZone?: string;
  };
  end: {
    date?: string;
    dateTime?: string;
    timeZone?: string;
  };
  index?: number; // Add this line
}
const TOTAL_EVENTS = 50;
const INITIAL_VISIBLE = 7;
const LOAD_MORE_INCREMENT = 5;
const fetchEvents = async () => {
  const now = new Date().toISOString();
  const url = `https://www.googleapis.com/calendar/v3/calendars/${CALENDAR_ID}/events?key=${API_KEY}&timeMin=${now}&maxResults=${TOTAL_EVENTS}&orderBy=startTime&singleEvents=true`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("Failed to fetch events");
    const data = await res.json();
    return (data.items ?? []) as GoogleCalendarEvent[];
  } catch (err) {
    return null;
  }
};
const eventsData = await fetchEvents();
function groupEventsByDate(events: GoogleCalendarEvent[]) {
  const grouped: Record<string, GoogleCalendarEvent[]> = {};
  events.forEach((event, index) => {
    const date = event.start.date || event.start.dateTime?.slice(0, 10);
    if (!date) throw new Error("Event is missing a start date");
    if (!grouped[date]) grouped[date] = [];
    grouped[date].push({ ...event, index });
  });
  return grouped;
}
function formatDate(dateStr: string, tz?: string) {
  const date = new Date(dateStr);
  const locale = lang === "en" ? "en-US" : "ro-RO";
  const formattedDate = date.toLocaleDateString(locale, {
    weekday: "long",
    day: "numeric",
    month: "long",
    ...(tz ? { timeZone: tz } : {}),
  });
  return formattedDate
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
function formatTimeRange(
  startDateTime?: string,
  endDateTime?: string,
  tz?: string,
) {
  if (!startDateTime) return "";
  const locale = lang === "en" ? "en-US" : "ro-RO";
  const start = new Date(startDateTime).toLocaleTimeString(locale, {
    hour: "2-digit",
    minute: "2-digit",
    ...(tz ? { timeZone: tz } : {}),
  });
  let end = "";
  if (endDateTime) {
    end = new Date(endDateTime).toLocaleTimeString(locale, {
      hour: "2-digit",
      minute: "2-digit",
      ...(tz ? { timeZone: tz } : {}),
    });
    return `${start} - ${end}`;
  }
  return start;
}
function parseDescription(description?: string) {
  if (!description)
    return {
      detailsLink: null,
      registerLink: null,
      text: "",
      enDescription: null,
      enTitle: null,
    };
  let text = description;
  const tokenPattern = "(?:detailsLink|registerLink|enTitle|enDescription)";
  const extractField = (field: string) => {
    const regex = new RegExp(
      `${field}\\s*:\\s*([\\s\\S]*?)(?=(?:\\s|<br\\s*\\/?>|<[^>]+>)*(?:${tokenPattern})\\s*:|$)`,
      "i",
    );
    const match = text.match(regex);
    if (!match) return null;
    return {
      raw: match[0],
      value: match[1],
    };
  };
  let detailsLink = null;
  let registerLink = null;
  let enDescription = null;
  let enTitle = null;
  // Match anchor tag, plain URL, or www.* for detailsLink
  const detailsMatch = description.match(
    /detailsLink:\s*(?:<a[^>]*href=["']([^"']+)["'][^>]*>.*?<\/a>|(https?:\/\/[^\s<]+)|(www\.[^\s<]+))/,
  );
  if (detailsMatch) {
    detailsLink = detailsMatch[1] || detailsMatch[2] || detailsMatch[3];
    if (detailsLink && !/^https?:\/\//.test(detailsLink)) {
      detailsLink = `https://${detailsLink}`;
    }
    text = text.replace(detailsMatch[0], "");
  }
  // Match anchor tag, plain URL, or www.* for registerLink
  const registerMatch = description.match(
    /registerLink:\s*(?:<a[^>]*href=["']([^"']+)["'][^>]*>.*?<\/a>|(https?:\/\/[^\s<]+)|(www\.[^\s<]+))/,
  );
  if (registerMatch) {
    registerLink = registerMatch[1] || registerMatch[2] || registerMatch[3];
    if (registerLink && !/^https?:\/\//.test(registerLink)) {
      registerLink = `https://${registerLink}`;
    }
    text = text.replace(registerMatch[0], "");
  }
  // Extract enTitle (if present) and remove it from base text
  const enTitleMatch = extractField("enTitle");
  if (enTitleMatch) {
    enTitle = enTitleMatch.value
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim();
    text = text.replace(enTitleMatch.raw, "");
  }
  // Extract enDescription (if present) and remove it from base text
  const enMatch = extractField("enDescription");
  if (enMatch) {
    enDescription = enMatch.value.replace(/(<br\s*\/?>)+/g, "\n").trim();
    text = text.replace(enMatch.raw, "");
  }
  // Remove extra <br> tags and trim
  text = text.replace(/(<br\s*\/?>)+/g, "\n").trim();
  return { detailsLink, registerLink, text, enDescription, enTitle };
}
---

{
  Array.isArray(eventsData) && eventsData.length > 0 && (
    <div
      class="w-full p-4 max-w-lg"
      x-data={`{
        visibleCount: ${INITIAL_VISIBLE},
        totalEvents: ${eventsData.length},
        showMore() {
          this.visibleCount = Math.min(this.visibleCount + ${LOAD_MORE_INCREMENT}, this.totalEvents)
        }
      }`}
      x-init="function() {
        const params = new URLSearchParams(window.location.search);
        const targetId = params.get('scrollTo'); // e.g. ?scrollTo=section2

        if (targetId) {
          const el = document.getElementById(targetId);
          if (el) {
            // Delay to ensure layout is ready
            setTimeout(() => {
              el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          }
        }
      }()"
    >
      {title && <h2 class="text-3xl mb-4">{title}</h2>}
      <ul class="space-y-4">
        {Object.entries(groupEventsByDate(eventsData)).map(([date, events]) => (
          <li x-show={`visibleCount > ${events[0].index}`} x-transition>
            <h3 class="font-semibold mb-2">
              {formatDate(
                date,
                events[0]?.start?.timeZone || events[0]?.end?.timeZone,
              )}
            </h3>
            <ul class="space-y-2">
              {events.map((event: GoogleCalendarEvent) => {
                const {
                  detailsLink,
                  registerLink,
                  text,
                  enDescription,
                  enTitle,
                } = parseDescription(event.description);
                const description =
                  lang === "en" && enDescription ? enDescription : text;
                const eventTitle =
                  lang === "en" && enTitle ? enTitle : event.summary;
                const eventTimeZone =
                  event.start?.timeZone || event.end?.timeZone;
                return (
                  <CalendarEvent
                    title={eventTitle}
                    description={description}
                    timeRange={formatTimeRange(
                      event.start.dateTime,
                      event.end?.dateTime,
                      eventTimeZone,
                    )}
                    detailsLink={detailsLink || undefined}
                    registerLink={registerLink || undefined}
                    isVisible={`visibleCount > ${event.index}`}
                    lang={lang}
                  />
                );
              })}
            </ul>
          </li>
        ))}
      </ul>

      <button
        x-show="visibleCount < totalEvents"
        @click="showMore()"
        class="w-full mt-4 px-4 py-2 text-secondary-pink border border-secondary-pink rounded-full transition-colors"
      >
        {t("calendar.loadMore")}
      </button>
    </div>
  )
}
